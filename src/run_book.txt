jfrog rt search --spec=/tmp/jfrogfilespec.json --sort-by created --sort-order=desc --limit 1

{ "files": [ { "aql": { "items.find": { "repo":{"$eq":"my-release-repo"}, "name":{"$match":"my-artifact-prefix*"} } } } ] }

set JFROG_CLI_LOG_LEVEL=DEBUG

curl --insecure --tlsv1.1 -i https://www.allegiantair.com/ --noproxy "*"

curl --insecure --tlsv1.2 -i https://www.allegiantair.com/ --noproxy "*"

Consider the widely accepted DevOps concept of Pets vs. Cattle. In a traditional data center, servers are treated
as Pets
: a physical machine, given a meaningful name, and cared for. You scale by adding more resources to the
same machine (scaling up). If the server becomes sick, you nurse it back to health. Should the server become
unavailable, everyone notices.
The
Cattle
 service model is different. You provision each instance as a virtual machine or container. They're
identical and assigned a system identifier such as Service-01, Service-02, and so on. You scale by creating more
of them (scaling out). When one becomes unavailable, nobody notices.
The cattle model embraces
immutable infrastructure
. Servers aren't repaired or modified. If one fails or requires
updating, it's destroyed and a new one is provisioned â€“ all done via automation.
Cloud-native systems embrace the Cattle service model. They continue to run as the infrastructure scales in or
out with no regard to the machines upon which they're running.
The Azure cloud platform supports this type of highly elastic infrastructure with automatic scaling, self-healing,
and monitoring capabilities.